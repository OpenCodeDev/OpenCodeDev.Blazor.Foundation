@page "/wasm/testmarkdown"
@using System.Reflection
@using OpenCodeDev.Blazor.Foundation.Doc.Core.Components.Containers.Section;
@using OpenCodeDev.Blazor.Foundation.Components.Controls;
@using OpenCodeDev.Blazor.Foundation.Components.Containers;
@inject NavigationManager Navigator;
@using System.Net.Http;
@using System.Text
@using System.Text.RegularExpressions
@using OpenCodeDev.Blazor.Foundation.Doc.Core.Plugins
@using OpenCodeDev.Blazor.Foundation.Doc.Core.Plugins.Markdown;
@inject HttpClient _client

@if (IsLoading)
{
    <span class="mdi mdi-loading mdi-spin"> @("Loading Document")</span>
}
else{
    @if (HasError)
    {
     <Callout TypeClass="alert">
         @Error
     </Callout>
    }else{
        @foreach (var item in ParsedMarkdown.OrderBy(p => p.Position))
        {
            @if (item.Html != null) 
                @item.Html
            else if (item.Fragment != null)
                @item.Fragment

        }
    }
}


@code {

    public string RawPage { get; set; }
    private bool IsLoading { get; set; } = true;
    private bool HasError { get; set; }
    private string Error { get; set; }
    private string Location {get; set;}

    private List<MarkdownElement> ParsedMarkdown { get; set; } = new List<MarkdownElement>();

    protected override void OnParametersSet()
    {

        Location = $"{Navigator.BaseUri}/_content/OpenCodeDev.Blazor.Foundation.Doc.Core/TestDoc.md";
    }
    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            FetchPage();
        }
    }

    private async Task FetchPage()
    {
        IsLoading = true;
        StateHasChanged();
        try {
            RawPage = await _client.GetStringAsync(Location);
            await ProcessDocument();
            StateHasChanged();
        } catch (Exception ex) {
            ParsedMarkdown.Add(new MarkdownElement(WarningMessage(ex.Message), 0));
        } finally {
            IsLoading = false;
            StateHasChanged();
        }
    }

    private async Task ProcessDocument() {
        if (!string.IsNullOrEmpty(RawPage)) {
            // Create MardownParser.
            var mdParser = new MarkdownParser();
            List<int[]> blazorChoping = new();
            // Parse All Object First.
            foreach (var rule in mdParser.MdRules) {
                try {

                    MatchCollection matches = Regex.Matches(RawPage, rule.Regex);
                    if (matches.Count > 0)
                        foreach (Match item in matches) {
                            if (!item.Success) continue;
                            blazorChoping.Add(new int[] { item.Index, item.Length });
                            Console.WriteLine($"{item.Index} : {item.Length}");
                            MarkdownElement? mde = rule.ProcessValue(item.Value, item, item.Index);
                            if (mde == null) continue; // ignore failed.
                            ParsedMarkdown.Add(mde);
                        }
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.Message);
                    // Silence Errors
                }
            }
            string capture = "";
            int ignoreUntil = -1;
            int position = -1;
            for (int i = 0; i < RawPage.Length; i++)
            {
                int index = i;
                int[]? chop = blazorChoping.Find(p => p[0] == index);
                if (chop != null)
                {
                    ignoreUntil = chop[0] + chop[1];
                    if (capture.Length > 0) {
                        ParsedMarkdown.Add(new MarkdownElement((MarkupString)CommonMark.CommonMarkConverter.Convert(capture), position));
                    }
                    capture = ""; // reset capture;
                    position = -1;
                }
                if (index <= ignoreUntil) continue;
                if (position == -1) position = index;
                capture += RawPage[index];
            }
        }
        else
        {
            ParsedMarkdown.Add(new MarkdownElement(WarningMessage($"Document: {Location} is empty, misconfigured or could not be fetch."), 0));
        }
    }


    private RenderFragment WarningMessage(string message)
    {
        return builder =>
        {
            builder.OpenComponent<Callout>(0);
            builder.AddAttribute(0, "TypeClass", "warning");
            builder.AddContent(0, message);
            builder.CloseComponent();
        };
    }

    private RenderFragment CreateHighlightCode(string lang, string content)
    {
        return builder =>
        {
            builder.OpenComponent<HighlightCode>(0);
            builder.AddAttribute(0, "Language", lang);
            builder.AddAttribute(0, "Content", content);
            builder.CloseComponent();
        };
    }
}
